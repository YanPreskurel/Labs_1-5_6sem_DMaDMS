DROP TABLE GROUPS;
DROP TABLE STUDENTS;
DROP TABLE STUDENTS_LOG;

--Task1
CREATE TABLE GROUPS (
    ID NUMBER,
    NAME VARCHAR2(50),
    C_VAL NUMBER DEFAULT 0
);

CREATE TABLE STUDENTS (
    ID NUMBER,
    NAME VARCHAR2(50),
    GROUP_ID NUMBER
);

CREATE TABLE STUDENTS_LOG (
    LOG_ID NUMBER,
    LOG_DATE TIMESTAMP,
    ACTION VARCHAR2(50),
    STUDENT_ID NUMBER,
    NAME VARCHAR2(50),
    GROUP_ID NUMBER
);

CREATE SEQUENCE STUDENTS_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE;

CREATE SEQUENCE GROUPS_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE;

CREATE SEQUENCE LOG_SEQ
START WITH 1
INCREMENT BY 1
NOMAXVALUE;

--Task2
--Генерация автоинкрементного ключа
CREATE OR REPLACE TRIGGER trg_students_id
BEFORE INSERT ON STUDENTS
FOR EACH ROW
BEGIN
    SELECT STUDENTS_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;

--Проверка на уникальность полей ID
CREATE OR REPLACE TRIGGER trg_students_unique_id
BEFORE INSERT ON STUDENTS
FOR EACH ROW
BEGIN
    IF :NEW.ID IS NOT NULL THEN
        RAISE_APPLICATION_ERROR(-20001, 'ID must be NULL for new records');
    END IF;
END;

--проверка уникальности для поля GROUP.NAME
CREATE OR REPLACE TRIGGER trg_groups_unique_name
BEFORE INSERT ON GROUPS
FOR EACH ROW
DECLARE
    NEWOBJ NUMBER;
BEGIN
    SELECT COUNT(*) INTO NEWOBJ FROM GROUPS WHERE NAME = :NEW.NAME;
    IF (NEWOBJ) > 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Duplicate group name not allowed');
    END IF;
END;

--Task3
CREATE OR REPLACE TRIGGER trg_students_cascade_delete
BEFORE DELETE ON GROUPS
FOR EACH ROW
BEGIN
    DELETE FROM STUDENTS WHERE GROUP_ID = :OLD.ID;
END;

--Task4
CREATE OR REPLACE TRIGGER trg_students_logging
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO STUDENTS_LOG VALUES (LOG_SEQ.NEXTVAL, SYSTIMESTAMP, 'INSERT', :NEW.ID, :NEW.NAME, :NEW.GROUP_ID);
    ELSIF UPDATING THEN
        INSERT INTO STUDENTS_LOG VALUES (LOG_SEQ.NEXTVAL, SYSTIMESTAMP, 'UPDATE', :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
    ELSIF DELETING THEN
        INSERT INTO STUDENTS_LOG VALUES (LOG_SEQ.NEXTVAL, SYSTIMESTAMP, 'DELETE', :OLD.ID, :OLD.NAME, :OLD.GROUP_ID);
    END IF;
END;

--Task5
CREATE OR REPLACE PROCEDURE restore_data(p_log_id NUMBER)
AS
    v_log_data STUDENTS_LOG%ROWTYPE;
    v_sql_query VARCHAR2(4000);
BEGIN
    SELECT * INTO v_log_data FROM STUDENTS_LOG WHERE LOG_ID = p_log_id;

    IF v_log_data.ACTION = 'INSERT' THEN
        v_sql_query := 'INSERT INTO STUDENTS VALUES (' || v_log_data.STUDENT_ID || ', ''' || v_log_data.NAME || ''', ' || v_log_data.GROUP_ID || ')';
    ELSIF v_log_data.ACTION = 'UPDATE' THEN
        v_sql_query := 'UPDATE STUDENTS SET NAME = ''' || v_log_data.NAME || ''', GROUP_ID = ' || v_log_data.GROUP_ID || ' WHERE ID = ' || v_log_data.STUDENT_ID;
    ELSIF v_log_data.ACTION = 'DELETE' THEN
        v_sql_query := 'DELETE FROM STUDENTS WHERE ID = ' || v_log_data.STUDENT_ID;
    ELSE
        RAISE_APPLICATION_ERROR(-20003, 'Invalid action specified');
    END IF;

    -- Выполнение динамического SQL
    EXECUTE IMMEDIATE v_sql_query;
END;

--Task6
CREATE OR REPLACE TRIGGER trg_students_update_c_val
AFTER INSERT OR UPDATE OR DELETE ON STUDENTS
FOR EACH ROW
BEGIN
    UPDATE GROUPS
    SET C_VAL = (SELECT COUNT(*) FROM STUDENTS WHERE GROUP_ID = :NEW.GROUP_ID)
    WHERE ID = :NEW.GROUP_ID;
END;